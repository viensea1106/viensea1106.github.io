---
title:  "CyberSecurityRumble CTF 2024 - Quals"
mathjax: true
layout: post
---

Writeup some Crypto challenges from [CyberSecurityRumble CTF 2024 - Quals](https://ctftime.org/event/2224)

<img src="/images/2024-csr-ctf/banner.png" width="100%">





# BIGGER IS BETTER

> **Description**\
> *In the world of encryption, let me tell you, bigger is better, folks. When you're talking about RSA, you want an exponent that's huge, believe me. Some people say, "Oh, go small for efficiency." But I say, forget about efficiency, we're talking about security! With a big exponent, you're going to have the best security, nobody's going to crack it, nobody! So, remember: go big or go home, and you'll be winning bigly in cybersecurity!*
>
> **Attachments**\
> **[source](https://github.com/sajjadium/ctf-archives/tree/main/ctfs/CyberSecurityRumble/2024/Quals/crypto/Bigger_is_better)**

```python
import os
import gmpy2
import Crypto.Util.number as number
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

def gen_params():
    e = gmpy2.mpz(number.getPrime(520))
    while True:
        while True:
            p = gmpy2.mpz(number.getPrime(512))
            q = (p * gmpy2.invert(p - 1, e)) % e
            if q.is_prime():
                break

        n = p * q
        phi = (p-1)*(q-1)

        if gmpy2.gcd(e, phi) == 1 and e < phi:
            d = (1 + (e - 1) * phi) // e
            return (int(n), int(e), int(d))
        
flag = os.environ["FLAG"]
key = RSA.construct(gen_params())

cipher = PKCS1_OAEP.new(key)
ciphertext = cipher.encrypt(flag.encode())

print("Flag:", ciphertext.hex())
print("n:", key.n)
print("e:", key.e)
```

M·ªôt b√†i RSA c∆° b·∫£n, c√°c s·ªë nguy√™n t·ªë $$p, q$$ ƒë∆∞·ª£c sinh th·ªèa m√£n: $$q = \dfrac{p}{p-1} \pmod{e}$$ v·ªõi $e$ (public key) l√† s·ªë nguy√™n t·ªë $$\sim 520$$ bits. V·ªõi $$n, e$$ ƒë√£ bi·∫øt, d·ªÖ d√†ng thi·∫øt l·∫≠p ph∆∞∆°ng tr√¨nh ƒë·ªÉ t√¨m $$p, q$$ nh∆∞ sau:

$$
f(p) = p \times \dfrac{p}{p-1} - n\pmod{e}
$$

gi·∫£i ra $$p, q$$ th√¨ coi nh∆∞ xong!

### Full script

```python
from sage.all import *
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

c = int("01b61a99ec3144e1eb15dd819185c340c7b17b38d069f5189807681d3c7a26afe1088f6b270c9cf26915d857e83de910971054fb92926adb0226325317510ddc5129a21beb6241001e638f6981cbcb3cd5a0be8168ae21d149d83fd3e9b5f9115e28ab2320a201a522d25f4e14552434835af1bb22d3f710341ed22722011c0372", 16)
n = 597335689226045056913166505037840157078954264999700629833258496762227084400401604912493527516646939874075386574739856551056864389324619848840266776702144772354597990152158599522528018659755118263808518976172810917606196554528503935276695298154816588160752930883134894518555210481664717173645960866565960880557
e = 2634065751614482329107725637023560471652100411843894146340117230337954286149474325215157995353348215193206597222786188634557304190252766656287157923889937903

if __name__ == "__main__":
    PR = PolynomialRing(GF(e), names="x"); x = PR.gen()
    fx = x**2 - n*(x - 1)
    for p, _ in fx.roots():
        if is_prime(int(p)):
            q = n // int(p)
            assert is_prime(q)

            phi = int(p - 1)*int(q - 1)
            d = (1 + (e - 1) * phi) // e
            key = RSA.construct((int(n), int(e), int(d)))
            cipher = PKCS1_OAEP.new(key)
            m = cipher.decrypt(long_to_bytes(c))
            print(m)
```

> **<gg>Flag: CSR{e_g0e5_brrrrrrrr}</gg>**


# HSM

> **Description**\
> *We have build a secure HSM!*\
> `nc hsm.rumble.host 3229`
>
> **Attachments**\
> **[source](https://github.com/sajjadium/ctf-archives/tree/main/ctfs/CyberSecurityRumble/2024/Quals/crypto/hsm)**

```python
import os
import signal
import base64
import ed25519

from Crypto.Cipher import AES

KEY = os.urandom(32)
PHRASE = b'I want flag'

def print_menu():
    print('''
[1] create key
[2] sign message
[3] verify signature
    '''.strip())

    return input('> ')

def decrypt_key(key):
    """
    Decrypt the secret part of the key and reconstruct key object
    """
    key = base64.b64decode(key)

    nonce, sk, tag, vk = key[:12], key[12:44], key[44:60], key[60:]

    aes = AES.new(KEY, nonce=nonce, mode=AES.MODE_GCM)

    sk = aes.decrypt_and_verify(sk, tag)

    key = ed25519.SigningKey(sk_s=sk + vk)

    return key

def encrypt_key(key):
    """
    Encrypt the secret part of the key
    """

    key = key.sk_s

    sk, vk = key[:32], key[32:]

    nonce = os.urandom(12)

    aes = AES.new(KEY, nonce=nonce, mode=AES.MODE_GCM)

    sk, tag = aes.encrypt_and_digest(sk)

    return base64.b64encode(nonce + sk + tag + vk).decode()

def generate_key():
    sk, _ = ed25519.create_keypair()
    out = encrypt_key(sk)

    print(f'Your key is: {out}')


def sign_message():
    key = input('Hand me your  key: ').strip()
    key = decrypt_key(key)

    msg = input('Which message to sign?: ').strip().encode()

    if msg == PHRASE:
        print("I'm sorry Dave, I'm afraid I can't do that")
        return

    sig = key.sign(msg)
    sig = base64.b64encode(sig).decode()

    print(f'Signature: {sig}')


def verify_signature():
    key = input('Hand me your key: ').strip()
    key = decrypt_key(key)

    msg = input('Which message to verify?: ').strip().encode()

    sig = input('What is the signature?: ').strip().encode()
    sig = base64.b64decode(sig)

    pk = key.get_verifying_key()

    try:
        pk.verify(sig, msg)
        print("The signature is valid")

        if msg == PHRASE:
            print(os.environ["FLAG"])
    except ed25519.BadSignatureError:
        print("The signature is invalid")


def main():
    signal.alarm(300)

    while True:
        option = print_menu()

        match option:
            case '1':
                generate_key()
            case '2':
                sign_message()
            case '3':
                verify_signature()
            case _:
                print('Invalid option')

if __name__ == '__main__':
    main()
```

M·ªôt b√†i ch·ªØ k√Ω s·ªë... v√† m·ª•c ti√™u c·ªßa ta l√† k√Ω message <oo>I want flag</oo> ƒë·ªÉ l·∫•y flag. ƒê·ªÅ b√†i s·ª≠ d·ª•ng th∆∞ vi·ªán [python-ed25519](https://github.com/warner/python-ed25519), sao m·ªôt h·ªìi ƒë·ªçc source v√† m√≤ m·∫´m th√¨ m√¨nh ng·ªô ra l√† th·∫±ng ED25519 d√πng thu·∫≠t to√°n kh√°c v·ªõi [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)üòÖ

ƒê·∫ßu ti√™n m√¨nh s·∫Ω tr√¨nh b√†y qu·∫£ BUG nh√≠ nh·ªë c·ªßa b√†i n√†y (c√≥ l·∫Ω l√† unintended solution) l√† n·∫±m ·ªü h√†m <oo>verify_signature</oo>:

```python
[...]
def verify_signature():
    key = input('Hand me your key: ').strip()
    key = decrypt_key(key)

    msg = input('Which message to verify?: ').strip().encode()

    sig = input('What is the signature?: ').strip().encode()
    sig = base64.b64decode(sig)

    pk = key.get_verifying_key()

    try:
        pk.verify(sig, msg)
        print("The signature is valid")

        if msg == PHRASE:
            print(os.environ["FLAG"])
    except ed25519.BadSignatureError:
        print("The signature is invalid")
[...]
```

H√†m n√†y cho ph√©p user submit th·∫≥ng public key l√™n cho server d√πng ƒë·ªÉ verify signature lu√¥nüòÉ, ta ƒë·ªÉ √Ω h√†m <oo>decrypt_key</oo> ch·ªâ decrypt secret key kh√∫c ƒë·∫ßu th√¥i c√≤n public key ph·∫ßn sau gi·ªØ nguy√™n. N√™n l√† ta ch·ªâ vi·ªác:

- G·ªçi <oo>generate_key</oo> ƒë·ªÉ l·∫•y encrypted secret key t·ª´ server.
- Generate key pair ·ªü local v√† k√Ω message b·∫±ng private key c·ªßa ch√∫ng ta.
- Gh√©p encrypted secret key c·ªßa server v·ªõi public key c·ªßa ta v√† g·ª≠i l√™n server ƒë·ªÉ verify signature

Done! Ok gi·ªù th·ª≠ gi·∫£ s·ª≠ h√†m <oo>verify_signature</oo> b·ªè ch·ª©c nƒÉng cho user g·ª≠i key l√™n v√† lu√¥n d√πng public key c·ªßa server ƒë·ªÉ verify th√¨ sao, ti·∫øp theo s·∫Ω l√† c√°ch m√† m√¨nh nghƒ© l√† intended c·ªßa challenge n√†y. Tr∆∞·ªõc ti√™n c·∫ßn t√¨m hi·ªÉu v·ªÅ Ed25519 signatrue.


### Ed25519 parameters

M√¨nh ch·ªâ gi·ªõi thi·ªáu s∆° b·ªô tham s·ªë chu·∫©n m√† kh√¥ng ƒëi v√†o chi ti·∫øt vi·ªác t√≠nh to√°n tr√™n curve (v√¨ b√†i n√†y ta ch·ªâ focus v√†o ph·∫ßn signature th√¥i)

$$
ax^{2} + y^{2} \equiv 1 + dx^{2}y^{2}
$$

- $$p$$     = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed
- $$a$$     = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec
- $$d$$     = 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3
- $$n$$     = 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed
- $$G_{x}$$ = 0x216936D3CD6E53FEC0A4E231FDD6DC5C692CC7609525A7B2C9562D608F25D51A
- $$G_{y}$$ = 0x6666666666666666666666666666666666666666666666666666666666666658

### Ed25519 Key generation

- Sinh ng·∫´u nhi√™n 32-bytes secret key $$\textsf{sk}$$
- Sinh public key t·ª´ secret key: $$\textsf{pk} = \textsf{sk} \cdot G$$, v·ªõi $$G$$ l√† base point (c√≥ gi√° tr·ªã nh∆∞ m√¨nh ƒë√£ ƒë·ªÅ c·∫≠p ·ªü tr√™n).

$$\rightarrow$$ Return: $$\left(\overline{\textsf{pk}}, \underline{\textsf{sk}}\right)$$. ·ªû ƒë√¢y ta th·ªëng nh·∫•t:

- $$\overline{\textsf{X}}$$ l√† encoding ƒëi·ªÉm X sang bytes (32-bytes).
- $$\underline{\textsf{X}}$$ l√† encoding s·ªë nguy√™n X sang bytes (32-bytes).

### Ed25519 Signing

ƒê·ªÉ k√Ω message $$m$$ ta c·∫ßn s·ª≠ d·ª•ng b·ªô gi√° tr·ªã $$\left(\textsf{pk}, \textsf{sk}\right)$$, tr√¨nh t·ª± c√°c b∆∞·ªõc nh∆∞ sau:

- T√≠nh gi√° tr·ªã SHA-512 hash c·ªßa private key:

$$
h = \textsf{SHA-512}(\underline{\textsf{sk}}) = \overline{h_{1}h_{2}h_{3} \cdots h_{64}}
$$

- T√≠nh gi√° tr·ªã $$r$$ b·∫±ng c√°ch hash 32-bytes cu·ªëi c·ªßa $$h$$ concat v·ªõi $$m$$:

$$
r = \textsf{SHA-512}\left(\overline{h_{33}h_{34}h_{35} \cdots h_{64}} \text{  ||  } m\right)
$$


sau ƒë√≥ apply v√†o curve thu ƒë∆∞·ª£c ƒëi·ªÉm $$R = r \cdot G$$

- T√≠nh gi√° tr·ªã $$s$$:

$$
s = r + \textsf{sk} \cdot \textsf{SHA-512}\left(\overline{R} \text{  ||  } \overline{\textsf{pk}} \text{  ||  } m\right)
$$

$$\rightarrow$$ Return: $$\left(\overline{R}, \underline{s}\right)$$ m·ªói s·ªë t∆∞∆°ng ƒë∆∞∆°ng v·ªõi 32 bytes, v·∫≠y ƒë·ªô d√†i signature t·ªïng c·ªông l√† 64 bytes.

### Ed25519 Verifying

ƒê·ªÉ verify ta c·∫ßn s·ª≠ d·ª•ng c√°c gi√° tr·ªã: $$\left(\overline{R}, \underline{s}\right)$$. C√°c b∆∞·ªõc th·ª±c hi·ªán nh∆∞ sau:

- T√≠nh gi√° tr·ªã $$S$$:

$$
S = \textsf{SHA-512}\left(\overline{R} \text{  ||  } \overline{\textsf{pk}} \text{  ||  } m \right)
$$

- T√≠nh c·∫∑p gi√° tr·ªã $$\left(v_{1}, v_{2}\right)$$:

$$
\begin{cases}
    v_{1} &= s \cdot G  \\
    v_{2} &= R + pk \cdot S
\end{cases}
$$

- Ki·ªÉm tra xem $$v_{1} \stackrel{?}{=} v_{2}$$, b·∫±ng nhau th√¨ signature h·ª£p l·ªá, d∆∞·ªõi ƒë√¢y l√† ch·ª©ng minh t√≠nh ƒë√∫ng ƒë·∫Øng c·ªßa thu·∫≠t to√°n:

$$
\begin{align*}
v_{1} &= s \cdot G \\
      &= \left(r + \textsf{sk} \cdot \textsf{SHA-512}\left(\overline{R} \text{  ||  } \overline{\textsf{pk}} \text{  ||  } m\right)\right) \cdot G \\
      &= r \cdot G + \textsf{SHA-512}\left(\overline{R} \text{  ||  } \overline{\textsf{pk}} \text{  ||  } m\right) \cdot \textsf{sk} \cdot G \\
      &= R + S \cdot \textsf{pk} \\
      &= v_{2}
\end{align*}
$$

### Implementation Vulnerability

Kh√°c v·ªõi thu·∫≠t to√°n ECDSA, m·ªói l·∫ßn k√Ω s·∫Ω k√®m theo 1 gi√° tr·ªã `nonce` gen ng·∫´u nhi√™n ƒë·ªÉ khi k√Ω c√πng 1 message v·ªõi c√πng b·ªô key th√¨ k·∫øt qu·∫£ m·ªói l·∫ßn k√Ω l√† kh√°c nhau.

Ed25519 th√¨ ng∆∞·ª£c l·∫°i, signature s·∫Ω c·ªë ƒë·ªãnh n·∫øu ta gi·ªØ nguy√™n $$(m, \textsf{sk}, \textsf{pk})$$. T·ª´ ƒë√¢y ta th·∫•y m·ªôt l·ªói nh·ªè trong qu√° tr√¨nh signing nh∆∞ sau: n·∫øu ta k√Ω c√πng m·ªôt message $$m$$ v·ªõi c√πng secret key $$\textsf{sk}$$ nh∆∞ng l·∫°i d√πng 2 public key $$\left(\textsf{pk}_{1},\textsf{pk}_{2}\right)$$ kh√°c nhau, ta ho√†n to√†n c√≥ th·ªÉ recover ƒë∆∞·ª£c gi√° tr·ªã $$\textsf{sk}$$. L·ªói n√†y ƒë·∫øn t·ª´ vi·ªác implement th∆∞ vi·ªán [python-ed25519](https://github.com/warner/python-ed25519) ƒë√£ kh√¥ng c√≥ b∆∞·ªõc check xem c·∫∑p kh√≥a $$\left(\textsf{sk},\textsf{pk}_{i}\right)$$ c√≥ h·ª£p l·ªá hay kh√¥ng tr∆∞·ªõc khi ti·∫øn h√†nh signing.

C√°c b∆∞·ªõc recover $$\textsf{sk}$$ t·ª´ 2 b·ªë signature $$\left(\overline{R}, \underline{s_{1}}\right), \left(\overline{R}, \underline{s_{2}}\right)$$ nh∆∞ sau:

- ƒê·∫ßu ti√™n ta th·∫•y gi√° tr·ªã $$\overline{R}$$ kh√¥ng ƒë·ªïi v√¨ n√≥ ch·ªâ ph·ª• thu·ªôc v√†o $$\textsf{sk}, m$$.
- T√≠nh 2 gi√° tr·ªã $$e_{1}, e_{2}$$ nh∆∞ sau:

$$
\begin{cases}
    e_{1} &= \textsf{SHA-512}\left(\overline{R} \text{  ||  } \overline{\textsf{pk}_{1}} \text{  ||  } m\right) \\
    e_{2} &= \textsf{SHA-512}\left(\overline{R} \text{  ||  } \overline{\textsf{pk}_{2}} \text{  ||  } m\right) \\
\end{cases}
$$

- Khi ƒë√≥ ta c√≥ h·ªá sau v·ªõi ·∫©n l√† $$\textsf{sk}$$:

$$
\begin{cases}
    s_{1} &= r + e_{1} \cdot \textsf{sk} \\
    s_{2} &= r + e_{2} \cdot \textsf{sk}
\end{cases} \pmod{n}
$$

$$\rightarrow$$ D·ªÖ d√†ng kh√¥i ph·ª•c gi√° tr·ªã $$\textsf{sk} = \dfrac{s_{1} - s_{2}}{e_{1} - e_{2}} \pmod{n}$$

### Intended Solution

Flow exploit nh∆∞ sau:

- ƒê·∫ßu ti√™n g·ªçi <oo>generate_key</oo> ƒë·ªÉ l·∫•y encrypted secret key t·ª´ server.
- S·ª≠a 32 bytes cu·ªëi ƒë·ªÉ t·∫°o th√†nh 2 c·∫∑p kh√≥a chung $$\textsf{sk}$$ nh∆∞ng kh√°c $$\textsf{pk}$$.
- G·ªçi <oo>sign_message</oo> v·ªõi c√πng message $$m$$ thu ƒë∆∞·ª£c 2 b·ªô signature, sau ƒë√≥ √°p d·ª•ng attack nh∆∞ m√¨nh ƒë√£ tr√¨nh b√†y ·ªü tr√™n ƒë·ªÉ recover $$\textsf{sk}$$.
- C√≥ $$\textsf{sk}$$ r·ªìi th√¨ mu·ªën k√Ω g√¨ ch·∫£ ƒë∆∞·ª£cüòÖ$$\rightarrow$$ done!

```python
from pwn import *
from base64 import b64decode, b64encode
from SignatureForgery import attack # https://github.com/viensea1106/Crypto4Fun/blob/main/src/Ed25519/SignatureForgery.py

def create_key():
    io.sendlineafter(b"> ", b"1")
    io.recvuntil(b": ")
    return b64decode(io.recvline().strip().decode())

def sign_message(key: bytes, message: bytes):
    io.sendlineafter(b"> ", b"2")
    io.sendlineafter(b": ", b64encode(key))
    io.sendlineafter(b": ", message)
    io.recvuntil(b": ")
    return b64decode(io.recvline().strip().decode())

def verify_signature(key: bytes, message: bytes, signature: bytes):
    io.sendlineafter(b"> ", b"3")
    io.sendlineafter(b": ", b64encode(key))
    io.sendlineafter(b": ", message)
    io.sendlineafter(b": ", b64encode(signature))

if __name__ == "__main__":
    io = remote("0", 3229)
    original_key = create_key()
    fake_key     = original_key[:-32] + os.urandom(32)
    original_msg = b"hacked by vnc!!!"
    target_msg   = b'I want flag'

    sig1 = sign_message(original_key, original_msg)
    sig2 = sign_message(fake_key, original_msg)
    forged_sig = attack(sig1, original_key[-32:], sig2, fake_key[-32:], original_msg, target_msg, original_key[-32:])
    verify_signature(original_key, target_msg, forged_sig)
    io.interactive()
```
> **<gg>Flag: CSR{did_I_already_said_nonce?}</gg>**