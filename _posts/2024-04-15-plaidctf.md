---
title:  "Plaid CTF 2024 - DHCPPP"
mathjax: true
layout: post
---

Writeup an interesting Crypto challenge from [Plaid CTF 2024](https://ctftime.org/event/2245)

<img src="/images/2024-plaid-ctf/logo.png" width="100%">




# DHCPPP

## Description

<img src="/images/2024-plaid-ctf/des.png" width="100%">

## Challenge Overview

```python
import time, zlib
import secrets
import hashlib
import requests
from Crypto.Cipher import ChaCha20_Poly1305
import dns.resolver

CHACHA_KEY = secrets.token_bytes(32)
TIMEOUT = 1e-1

def encrypt_msg(msg, nonce):
    # In case our RNG nonce is repeated, we also hash
    # the message in. This means the worst-case scenario
    # is that our nonce reflects a hash of the message
    # but saves the chance of a nonce being reused across
    # different messages
    nonce = sha256(msg[:32] + nonce[:32])[:12]

    cipher = ChaCha20_Poly1305.new(key=CHACHA_KEY, nonce=nonce)
    ct, tag = cipher.encrypt_and_digest(msg)

    return ct+tag+nonce

def decrypt_msg(msg):
    ct = msg[:-28]
    tag = msg[-28:-12]
    nonce = msg[-12:]

    cipher = ChaCha20_Poly1305.new(key=CHACHA_KEY, nonce=nonce)
    pt = cipher.decrypt_and_verify(ct, tag)

    return pt

def calc_crc(msg):
    return zlib.crc32(msg).to_bytes(4, "little")

def sha256(msg):
    return hashlib.sha256(msg).digest()

RNG_INIT = secrets.token_bytes(512)

class DHCPServer:
    def __init__(self):
        self.leases = []
        self.ips = [f"192.168.1.{i}" for i in range(3, 64)]
        self.mac = bytes.fromhex("1b 7d 6f 49 37 c9")
        self.gateway_ip = "192.168.1.1"

        self.leases.append(("192.168.1.2", b"rngserver_0", time.time(), []))

    def get_lease(self, dev_name):
        if len(self.ips) != 0:
            ip = self.ips.pop(0)
            self.leases.append((ip, dev_name, time.time(), []))
        else:
            # relinquish the oldest lease
            old_lease = self.leases.pop(0)
            ip = old_lease[0]
            self.leases.append((ip, dev_name, time.time(), []))

        pkt = bytearray(
            bytes([int(x) for x in ip.split(".")]) +
            bytes([int(x) for x in self.gateway_ip.split(".")]) +
            bytes([255, 255, 255, 0]) +
            bytes([8, 8, 8, 8]) +
            bytes([8, 8, 4, 4]) +
            dev_name +
            b"\x00"
        )

        pkt = b"\x02" + encrypt_msg(pkt, self.get_entropy_from_lavalamps()) + calc_crc(pkt)

        return pkt

    def get_entropy_from_lavalamps(self):
        # Get entropy from all available lava-lamp RNG servers
        # Falling back to local RNG if necessary
        entropy_pool = RNG_INIT

        for ip, name, ts, tags in self.leases:
            if b"rngserver" in name:
                try:
                    # get entropy from the server
                    output = requests.get(f"http://{ip}/get_rng", timeout=TIMEOUT).text
                    entropy_pool += sha256(output.encode())
                except:
                    # if the server is broken, get randomness from local RNG instead
                    entropy_pool += sha256(secrets.token_bytes(512))

        return sha256(entropy_pool)

    def process_pkt(self, pkt):
        assert pkt is not None

        src_mac = pkt[:6]
        dst_mac = pkt[6:12]
        msg = pkt[12:]

        if dst_mac != self.mac:
            return None

        if src_mac == self.mac:
            return None

        if len(msg) and msg.startswith(b"\x01"):
            # lease request
            dev_name = msg[1:]
            lease_resp = self.get_lease(dev_name)
            return (
                self.mac +
                src_mac + # dest mac
                lease_resp
            )
        else:
            return None

class FlagServer:
    def __init__(self, dhcp):
        self.mac = bytes.fromhex("53 79 82 b5 97 eb")
        self.dns = dns.resolver.Resolver()
        self.process_pkt(dhcp.process_pkt(self.mac+dhcp.mac+b"\x01"+b"flag_server"))

    def send_flag(self):
        with open("flag.txt", "r") as f:
            flag = f.read().strip()
        curl("example.com", f"/{flag}", self.dns)

    def process_pkt(self, pkt):
        assert pkt is not None

        src_mac = pkt[:6]
        dst_mac = pkt[6:12]
        msg = pkt[12:]

        if dst_mac != self.mac:
            return None

        if src_mac == self.mac:
            return None

        if len(msg) and msg.startswith(b"\x02"):
            # lease response
            pkt = msg[1:-4]
            pkt = decrypt_msg(pkt)
            crc = msg[-4:]
            assert crc == calc_crc(pkt)

            self.ip = ".".join(str(x) for x in pkt[0:4])
            self.gateway_ip = ".".join(str(x) for x in pkt[4:8])
            self.subnet_mask = ".".join(str(x) for x in pkt[8:12])
            self.dns1 = ".".join(str(x) for x in pkt[12:16])
            self.dns2 = ".".join(str(x) for x in pkt[16:20])
            self.dns.nameservers = [self.dns1, self.dns2]
            assert pkt.endswith(b"\x00")

            print("[FLAG SERVER] [DEBUG] Got DHCP lease", self.ip, self.gateway_ip, self.subnet_mask, self.dns1, self.dns2)

            return None

        elif len(msg) and msg.startswith(b"\x03"):
            # FREE FLAGES!!!!!!!
            self.send_flag()
            return None

        else:
            return None

def curl(url, path, dns):
    ip = str(dns.resolve(url).response.resolve_chaining().answer).strip().split(" ")[-1]
    url = "http://" + ip
    print(f"Sending flage to {url}")
    requests.get(url + path)

if __name__ == "__main__":
    dhcp = DHCPServer()
    flagserver = FlagServer(dhcp)

    while True:
        pkt = bytes.fromhex(input("> ").replace(" ", "").strip())

        out = dhcp.process_pkt(pkt)
        if out is not None:
            print(out.hex())

        out = flagserver.process_pkt(pkt)
        if out is not None:
            print(out.hex())
```

Code khÃ¡ dÃ i nÃªn mÃ¬nh sáº½ chia ra phÃ¢n tÃ­ch tá»«ng pháº§n:

<b>DHCPServer</b>

ÄÃºng nhÆ° tÃªn gá»i, chá»©c nÄƒng cá»§a nÃ³ lÃ  cáº¥p phÃ¡t Ä‘á»‹a chá»‰ IP vÃ  cáº­p nháº­t thÃ´ng tin vÃ´ record (leases).

$$\diamond$$ <yy>__init__(self):</yy> 

Khai bÃ¡o cÃ¡c giÃ¡ trá»‹ máº·c Ä‘á»‹nh nhÆ°:

- `leases`: danh sÃ¡ch chá»©a thÃ´ng tin IP Ä‘Ã£ Ä‘Æ°á»£c cáº¥p phÃ¡t.
- `ips`: IP pool chá»©a danh sÃ¡ch IP chÆ°a Ä‘Æ°á»£c cáº¥p phÃ¡t (<b>192.168.1.3</b> $$\rightarrow$$ <b>192.168.1.63</b>)
- `mac`: Ä‘á»‹a chá»‰ MAC cá»§a DHCP server.
- `gateway_ip`: IP cá»§a gateway.

Máº·c Ä‘á»‹nh sáº½ tá»± Ä‘á»™ng cáº¥p IP <b>192.168.1.2</b> cho thiáº¿t bá»‹ tÃªn `rngserver_0`.

```python
    self.leases = []
    self.ips = [f"192.168.1.{i}" for i in range(3, 64)]
    self.mac = bytes.fromhex("1b 7d 6f 49 37 c9")
    self.gateway_ip = "192.168.1.1"
    self.leases.append(("192.168.1.2", b"rngserver_0", time.time(), []))
```

$$\diamond$$ <yy>get_lease(self, dev_name):</yy> 

HÃ m nÃ y gá»‘m 2 má»¥c Ä‘Ã­ch chÃ­nh:

- Cáº¥p phÃ¡t Ä‘á»‹a chá»‰ IP: láº¥y tá»« IP pool náº¿u cÃ²n trá»‘ng, náº¿u IP pool háº¿t thÃ¬ láº¥y IP cÅ© nháº¥t Ä‘Ã£ cáº¥p trÆ°á»›c Ä‘Ã³ (pop tá»« `leases`)

```python
if len(self.ips) != 0:
    ip = self.ips.pop(0)
    self.leases.append((ip, dev_name, time.time(), []))
else:
    # relinquish the oldest lease
    old_lease = self.leases.pop(0)
    ip = old_lease[0]
    self.leases.append((ip, dev_name, time.time(), []))
```

- Táº¡o pháº§n payload cá»§a DHCP response: bao gá»“m cÃ¡c trÆ°á»ng thÃ´ng tin nhÆ° IP Ä‘Æ°á»£c cáº¥p phÃ¡t, IP gateway, Subnet mask, DNS servers, Device's name (tÃªn cá»§a thiáº¿t bá»‹ trong máº¡ng Ä‘ang yÃªu cáº§u cáº¥p IP cho nÃ³), NULL-Byte (Terminator cá»§a pháº§n payload).

```python
pkt = bytearray(
    bytes([int(x) for x in ip.split(".")]) +
    bytes([int(x) for x in self.gateway_ip.split(".")]) +
    bytes([255, 255, 255, 0]) +
    bytes([8, 8, 8, 8]) +
    bytes([8, 8, 4, 4]) +
    dev_name +
    b"\x00"
)
```

- Encrypt vÃ  Ä‘Ã³ng gÃ³i payload: toÃ n bá»™ thÃ´ng tin Ä‘á» cáº­p phÃ­a trÃªn sáº½ Ä‘Æ°á»£c mÃ£ hÃ³a báº±ng thuáº­t toÃ¡n [ChaCha20-Poly1305](https://en.wikipedia.org/wiki/ChaCha20-Poly1305) cuá»‘i cÃ¹ng Ä‘Ã³ng gÃ³i payload báº±ng cÃ¡ch thÃªm vÃ o trÆ°á»›c payload byte <b>0x02</b> (Seperator giá»¯a header vÃ  payload cá»§a DHCP packet) vÃ  phÃ­a sau payload giÃ¡ trá»‹ [CRC32 Checksum](https://en.wikipedia.org/wiki/Cyclic_redundancy_check).

```python
pkt = b"\x02" + encrypt_msg(pkt, self.get_entropy_from_lavalamps()) + calc_crc(pkt)
return pkt
```

$$\diamond$$ <yy>get_entropy_from_lavalamps(self):</yy> 

Vá» cÆ¡ báº£n thÃ¬ hÃ m nÃ y dÃ¹ng Ä‘á»ƒ táº¡o giÃ¡ trá»‹ `nonce` cho quÃ¡ trÃ¬nh mÃ£ hÃ³a ChaCha20-Poly1305 á»Ÿ bÃªn trÃªn. Äáº§u tiÃªn khai bÃ¡o `entropy_pool = RNG_INIT` tiáº¿p theo duyá»‡t qua danh sÃ¡ch IP Ä‘Ã£ Ä‘Æ°á»£c cáº¥p phÃ¡t (leases) náº¿u nhÆ° phÃ¡t hiá»‡n cÃ³ thiáº¿t bá»‹ nÃ o trong máº¡ng cÃ³ tÃªn (`dev_name`) chá»©a <b>"rngserver"</b> thÃ¬ tiáº¿t hÃ nh káº¿t ná»‘i tá»›i nÃ³ Ä‘á»ƒ láº¥y giÃ¡ trá»‹ random rá»“i thÃªm vÃ o `entropy_pool` (trÆ°á»ng há»£p káº¿t há»‘i khÃ´ng Ä‘Æ°á»£c thÃ¬ gá»i hÃ m `secrets.token_bytes(512)`).

```python
# Get entropy from all available lava-lamp RNG servers
# Falling back to local RNG if necessary
entropy_pool = RNG_INIT

for ip, name, ts, tags in self.leases:
    if b"rngserver" in name:
        try:
            # get entropy from the server
            output = requests.get(f"http://{ip}/get_rng", timeout=TIMEOUT).text
            entropy_pool += sha256(output.encode())
        except:
            # if the server is broken, get randomness from local RNG instead
            entropy_pool += sha256(secrets.token_bytes(512))

return sha256(entropy_pool)
```

$$\diamond$$ <yy>process_pkt(self):</yy> 

Pháº§n nÃ y sáº½ xá»­ lÃ½ chá»©c nÄƒng chÃ­nh lÃ  tiáº¿p nháº­n, xá»­ lÃ½ DHCP request sau Ä‘Ã³ tráº£ response vá». Cáº¥u trÃºc cá»§a DHCP packet nhÆ° sau:

- DHCP request packet:

```python
REQUEST = bytearray(
    bytes.fromhex("11 22 33 44 55 66") +  # From: MAC Address of requested deivce
    bytes.fromhex("1b 7d 6f 49 37 c9") +  # To  : MAC Address of DHCP server
    b"\x01"                            +  # SEPERATOR
    b"dev_name"                           # Device's name
)
```

- DHCP response packet:

```python
RESPONSE = bytearray(
    bytes.fromhex("1b 7d 6f 49 37 c9") +  # From : MAC Address of DHCP server
    bytes.fromhex("11 22 33 44 55 66") +  # To   : MAC Address of requested deivce
    b"\x02"                            +  # SEPERATOR
    bytes([192, 168, 1, 3])            +  # Allocated IP    |
    bytes([192, 168, 1, 1])            +  # Gateway's IP    |
    bytes([255, 255, 255, 0])          +  # Subnet mask     |
    bytes([8, 8, 8, 8])                +  # DNS servers     | <--- This part is encrypted!!!
    bytes([8, 8, 4, 4])                +  # DNS servers     |
    b"dev_name"                        +  # Device's name   |
    b"\x00"                            +  # TERMINATOR      |
    calc_crc                              # CRC32 Checksum
)
```

<b>FlagServer</b>

ÄÃ³ng vai trÃ² lÃ  1 server trong há»‡ thá»‘ng máº¡ng, tiáº¿p nháº­n request vÃ  thá»±c hiá»‡n cÃ¡c nhÆ° nÄƒng sau Ä‘Ã¢y:

$$\diamond$$ <yy>__init__(self, dhcp):</yy> 

Setup cÃ¡c giÃ¡ trá»‹ máº·c Ä‘á»‹nh nhÆ° MAC address, DNS resolver vÃ  gá»­i gÃ³i tin tá»›i DHCP server Ä‘á»ƒ khá»Ÿi táº¡o cÃ¡c giÃ¡ trá»‹ nhÆ° IP, Gateway's IP, Subnet mask, DNS Nameservers.

```python
self.mac = bytes.fromhex("53 79 82 b5 97 eb")
self.dns = dns.resolver.Resolver()
self.process_pkt(dhcp.process_pkt(self.mac+dhcp.mac+b"\x01"+b"flag_server"))
```

$$\diamond$$ <yy>process_pkt(self, pkt):</yy> 

NÆ¡i nháº­n vÃ  xá»­ lÃ½ tÃ¹y theo request packet:

- Cáº­p nháº­t thÃ´ng tin cho tin cho FlagServer báº±ng cÃ¡ch gá»­i packet cÃ³ cáº¥u trÃºc nhÆ° sau:

```python
REQUEST = bytearray(
    bytes.fromhex("11 22 33 44 55 66") +  # From : MAC Address of requested deivce
    bytes.fromhex("1b 7d 6f 49 37 c9") +  # To   : MAC Address of Flag server
    b"\x02"                            +  # SEPERATOR
    bytes([192, 168, 1, 3])            +  # Allocated IP    |
    bytes([192, 168, 1, 1])            +  # Gateway's IP    |
    bytes([255, 255, 255, 0])          +  # Subnet mask     |
    bytes([8, 8, 8, 8])                +  # DNS servers     | <--- This part is encrypted!!!
    bytes([8, 8, 4, 4])                +  # DNS servers     |
    b"dev_name"                        +  # Device's name   |
    b"\x00"                            +  # TERMINATOR      |
    calc_crc                              # CRC32 Checksum
)
```

$$\rightarrow$$ CÃ³ cáº¥u trÃºc giá»‘ng nhÆ° DHCP response (chá»‰ thay Ä‘á»•i Ä‘á»‹a chá»‰ MAC). Sau khi process thÃ nh cÃ´ng sáº½ in ra thÃ´ng bÃ¡o tráº£ vá»:

```python
print("[FLAG SERVER] [DEBUG] Got DHCP lease", self.ip, self.gateway_ip, self.subnet_mask, self.dns1, self.dns2)
```

- Gá»­i Flag: báº±ng cÃ¡ch curl example.com vá»›i Flag lÃ  Ä‘Æ°á»ng dáº«n, Ä‘áº§u tiÃªn sáº½ gá»i dns resolve tá»›i DNS server (máº·c Ä‘á»‹nh lÃ  DNS cá»§a google 8.8.8.8) Ä‘á»ƒ phÃ¢n giáº£i tÃªn miá»n example.com ra IP, cuá»‘i cÃ¹ng lÃ  gá»i get requests tá»›i <b>http://{ip}/flag</b>

```python
REQUEST = bytearray(
    bytes.fromhex("11 22 33 44 55 66") +  # From : MAC Address of requested deivce
    bytes.fromhex("1b 7d 6f 49 37 c9") +  # To   : MAC Address of Flag server
    b"\x03"                            +  # SEPERATOR
)
```

<img src="/images/2024-plaid-ctf/flow_flag.png" width="100%">

<b>Flow challenge</b>

Ta Ä‘Æ°á»£c phÃ©p gá»­i vÃ´ háº¡n láº§n request packet lÃªn DHCPServer hoáº·c FlagServer Ä‘á»ƒ dÃ¹ng cÃ¡c chá»©c nÄƒng sau:

- `DHCPServer`: nháº­n vá» DHCP packet response.
- `FlagServer`: cáº¥p phÃ¡t dns nameservers cho FlagServer hoáº·c lÃ  call lá»‡nh gá»­i Flag.

## Finding BUG

### How to get Flag?

- Muá»‘n Ä‘á»c flag thÃ¬ ta cáº§n host 1 public DNS server, DNS server nÃ y sáº½ phÃ¢n giáº£i domain example.com trá» vá» IP (cÅ©ng public luÃ´n) do ta kiá»ƒm soÃ¡t. TrÃªn IP nÃ y pháº£i má»Ÿ port 80 Ä‘á»ƒ khi curl flag tá»›i ta cÃ³ thá»ƒ Ä‘á»c Ä‘Æ°á»£c:

<img src="/images/2024-plaid-ctf/test_curl.png" width="100%">

- NhÆ° váº­y váº¥n Ä‘á» cá»§a ta lÃ  gá»­i packet Ä‘á»ƒ tÃ¹y chá»‰nh dns nameservers cá»§a FlagServer vá» DNS cá»§a ta host, sau Ä‘Ã³ trigger FlagServer gá»­i flag lÃ  xong!

### How to get a "free" valid request packet?

ChÃºng ta cÃ³ thá»ƒ request DHCP trÆ°á»›c, nháº­n Ä‘Æ°á»£c DHCP response tráº£ vá» vÃ  sau Ä‘Ã³ chá»‰nh MAC á»Ÿ pháº§n header Ä‘á»ƒ gá»­i tá»›i FlagServer. Tuy nhiÃªn viá»‡c lÃ m tháº­t vÃ´ nghÄ©a vÃ¬ thá»© ta cáº§n kiá»ƒm soÃ¡t lÃ  trÆ°á»ng DNS server, viá»‡c láº¥y packet trá»±c tiáº¿p tá»« DHCP server response ta chá»‰ kiá»ƒm soÃ¡t Ä‘Æ°á»£c ip vá»›i dev_name, tuy nhiÃªn hai thá»© nÃ y khÃ´ng áº£nh hÆ°á»Ÿng gÃ¬ tá»›i viá»‡c láº¥y Flag

### But how to create arbitrary valid request packet?

OK muá»‘n kiá»ƒm soÃ¡t Ä‘Æ°á»£c dns nameservers báº¯t buá»™c ta gáº§n pháº£i bypass bÆ°á»›c verify sau Ä‘Ã¢y:

- <b>pkt = decrypt_msg(pkt)</b>: Äáº§u tiÃªn thÃ¬ pkt cá»§a ta pháº£i "decrypt Ä‘Æ°á»£c". VÃ¬ nÃ³ Ä‘Æ°á»£c mÃ£ hÃ³a báº±ng ChaCha20_Poly1305 (Authenticated Encryption) tá»©c ngoÃ i viá»‡c giáº£i mÃ£ xong thÃ¬ cÃ²n bÆ°á»›c verify tag Ä‘á»ƒ xÃ¡c nháº­n message ban Ä‘áº§u khÃ´ng bá»‹ thay Ä‘á»•i.

$$\Rightarrow$$ NhÆ° váº­y rÃµ rÃ ng ta pháº£i cÃ³ kháº£ nÄƒng encrypt 1 packet báº¥t kÃ¬ Ä‘á»ƒ sau khi decrypt thÃ¬ váº«n trÃ­ch suáº¥t Ä‘Æ°á»£c trÆ°á»ng DNS nameserver Ä‘Ãºng nhÆ° ta mong muá»‘n.

### A closer look at how the packet is encrypted

Biáº¿t lÃ  nÃ³ dÃ¹ng ChaCha20_Poly1305 nhÆ°ng giá» muá»‘n attack thÃ¬ ta cáº§n ngÃ³ nÃ³ kÄ© hÆ¡n, xem thá»­ cÃ¡ch challenge nÃ y sá»­ dá»¥ng thuáº­t toÃ¡n mÃ£ hÃ³a cÃ³ chá»— nÃ o sai sÃ³t khÃ´ng:

<img src="/images/2024-plaid-ctf/review_nonce.png" width="100%">

Hmm... generate nonce thÃ´i mÃ  cÃ³ tháº­t sá»± cáº§n "tá»‘n sá»©c" nhÆ° váº­y khÃ´ng ğŸ˜

$$\rightarrow$$ NguyÃªn táº¯t sá»‘ 1: cÃ ng rá»‘i cÃ ng dá»… dÃ­nh BUG ğŸ˜ƒ

### Trigger nonce-reused

Nháº­n tháº¥y má»™t sá»‘ Ä‘iá»ƒm sau:

- Khi <oo>self.leases</oo> khÃ´ng cÃ²n `rngserver` thÃ¬ giÃ¡ trá»‹ `entropy_pool` tráº£ vá» luÃ´n cá»‘ Ä‘á»‹nh. Ta cÃ³ Ä‘á»ƒ request dhcp liÃªn tá»¥c cho tá»›i khi nÃ³ pop tháº±ng `rngserver` ban Ä‘áº§u ra lÃ  Ä‘Æ°á»£c (vÃ¬ ta control `servername` Ä‘Æ°á»£c mÃ ).
- GiÃ¡ trá»‹ `nonce` thá»±c sá»± dÃ¹ng Ä‘á»ƒ mÃ£ hÃ³a chacha cÃ²n phá»¥ thuá»™c vÃ o 32 kÃ½ tá»± Ä‘áº§u cá»§a biáº¿n `msg`

```python

    nonce = sha256(msg[:32] + nonce[:32])[:12]

```

- Äá»ƒ 32 bytes Ä‘áº§u cá»§a `msg` cá»‘ Ä‘á»‹nh thÃ¬ ta cáº§n trÆ°á»ng <oo>Allocated IP</oo> vÃ  pháº§n Ä‘áº§u cá»§a <oo>Device's name</oo> giá»‘ng nhau (coi láº¡i cáº¥u trÃºc cá»§a request packet mÃ¬nh Ä‘Ã£ Ä‘á» cáº­p á»Ÿ trÃªn).

$$\rightarrow$$ Váº­y ta cÃ³ thá»ƒ trigger nonce-reused báº±ng cÃ¡ch:

- Äáº§u tiÃªn flush dhcp request Ä‘á»ƒ pop tháº±ng `rngserver` ra.
- Sau Ä‘Ã³ request dhcp liÃªn tá»¥c, lÃºc nÃ y cá»© má»—i packet cÃ¡ch nhau 61 láº§n sáº½ Ä‘Æ°á»£c cáº¥p IP giá»‘ng nhau nhau, váº­y chá»‰ viá»‡c cho device's name giá»‘ng nhau ná»¯a (Ä‘á»§ dÃ i) thÃ¬ khi Ä‘Ã³ `msg[:32]` sáº½ cá»‘ Ä‘á»‹nh.

### Ok nonce is reused, what next?

<yy>Ciphertext Forgery Attack</yy>

Chacha20 lÃ  stream cipher, khi nonce reused thÃ¬ keystream sáº½ giá»‘ng nhau, váº­y vá»›i 1 cáº·p (plaintext, ciphertext) ta hoÃ n toÃ n tÃ­nh Ä‘Æ°á»£c keystream, tá»« Ä‘Ã³ encrypt Ä‘Æ°á»£c báº¥t ká»³ plaintext nÃ o cÃ³ cÃ¹ng nonce vá»›i cáº·p (plaintext, ciphertext) lÃºc nÃ£y.

<yy>Tag Forgery Attack</yy>

Tiáº¿p theo cáº§n tÃ­nh Ä‘Æ°á»£c tag tá»« ciphertext, thuáº­t toÃ¡n Ä‘Æ°á»£c sá»­ dá»¥ng á»Ÿ Ä‘Ã¢y lÃ  [Poly1305](https://en.wikipedia.org/wiki/Poly1305):


$$
\textsf{Poly1305}(m, r, s) = \left( \sum_{i=0}^{} \left(m_i || 0x01\right) \cdot r^i \pmod{2^{130} - 5} \right) + s \pmod{2^{128}} \tag{1}
$$

vá»›i $$m$$ lÃ  ciphertext $$(r,s)$$ lÃ  cáº·p key Ä‘Æ°á»£c táº¡o tá»« `nonce`.

BÃ¢y giá» giáº£ sá»­ ta cÃ³ 2 cáº·p (ciphertext, tag) cÃ³ cÃ¹ng `nonce` láº§n lÆ°á»£t lÃ  $$(c_{1}, t_{1})$$ vÃ  $$(c_{2}, t_{2})$$. Tá»« phÆ°Æ¡ng trÃ¬nh $$(1)$$ cÃ³ thá»ƒ viáº¿t láº¡i nhÆ° sau

$$
t_{i} = f\left(c_{i}, r\right) + s + \Delta_{i}2^{128} \pmod{2^{130} - 5}
$$

vá»›i $$\Delta_{i}2^{128} \le 2^{130} - 5+ 2^{128}$$. Váº­y cÃ³ thá»ƒ triá»‡t tiÃªu $$s$$, thu Ä‘Æ°á»£c phÆ°Æ¡ng trÃ¬nh áº©n $$r$$ nhÆ° sau

$$
\begin{align*}
\textsf{F}(r) &= \left(f\left(c_{1}, r\right) + s + \Delta_{1}2^{128}\right) - \left(f\left(c_{2}, r\right) + s + \Delta_{2}2^{128}\right) &\pmod{2^{130} - 5} \\
              &= \left(f\left(c_{1}\right)-f\left(c_{2}\right)\right) + \left(\Delta_{1}-\Delta_{2}\right)2^{128} &\pmod{2^{130} - 5}
\end{align*}
$$

giáº£i phÆ°Æ¡ng trÃ¬nh trÃªn $$\mathbb{F}_{2^{130}-5}$$ dá»… dÃ ng thu Ä‘Æ°á»£c $$r$$ tá»« Ä‘Ã³ tÃ­nh Ä‘Æ°á»£c $$s$$. CÃ³ $$(r,s)$$ thÃ¬ coi nhÆ° cÃ³ thá»ƒ tÃ­nh tag tá»« ciphertext Ä‘Æ°á»£c rá»“i!

### Full solution

```python
from sage.all import *
from pwn import *
from poly1305 import Poly1305
from os import urandom
import  zlib

P  = 0x3fffffffffffffffffffffffffffffffb # 2^130-5
PR = PolynomialRing(GF(P), "x")
x  = PR.gen()


def calc_crc(msg):
    return zlib.crc32(msg).to_bytes(4, "little")

def divceil(divident, divisor):
    """Integer division with rounding up"""
    quot, r = divmod(divident, divisor)
    return quot + int(bool(r))

def make_dhcp_pkt(dev_name: bytes):
    return bytearray(
        bytes.fromhex("00 00 00 00 00 00") +    # src's mac
        bytes.fromhex("1b 7d 6f 49 37 c9") +    # dest's mac
        b"\x01"                            +    # seperator
        dev_name                                # device's name
    ).hex().encode()

def request_dhcp(dev_name: bytes, debug=False):
    io.sendlineafter(b"> ", make_dhcp_pkt(dev_name=dev_name))
    pkt = io.recvline().strip().decode()
    if debug:
        print(f"{dev_name} -> {pkt}")

    pkt = bytes.fromhex(pkt)
    msg = pkt[12:]
    assert msg.startswith(b"\x02")
    crc = msg[-4:]
    pkt = msg[1:-4]
    ct  = pkt[:-28]
    tag = pkt[-28:-12]
    iv  = pkt[-12:]

    return ct, tag, iv, crc

def flush_dhcp(n):
    for _ in range(n):
        io.sendlineafter(b"> ", make_dhcp_pkt(dev_name=b"cc"))

def pad16(data):
    """Return padding for the Associated Authenticated Data"""
    if len(data) % 16 == 0:
        return bytearray(0)
    else:
        return bytearray(16-(len(data)%16))

def create_poly(ct):
    def le_bytes_to_num(data):
        """Convert a number from little endian byte format"""
        ret = 0
        for i in range(len(data) - 1, -1, -1):
            ret <<= 8
            ret += data[i]
        return ret

    data  = b"" + pad16(b"")
    data += ct + pad16(ct)
    data += struct.pack('<Q', 0)
    data += struct.pack('<Q', len(ct))

    acc = 0
    for i in range(0, divceil(len(data), 16)):
        n = le_bytes_to_num(data[i*16:(i+1)*16] + b'\x01')
        acc += n
        acc = (x * acc)
    # acc += s
    return acc

if __name__ == "__main__":
    # io = remote("0", 5555)
    io = remote("dhcppp.chal.pwni.ng", 1337)
    salt = urandom(32)

    # ip = 192.168.1.3
    flush_dhcp(61)
    pt1 = bytearray(
        bytes([int(x) for x in "192.168.1.3".split(".")]) +
        bytes([int(x) for x in "192.168.1.1".split(".")]) +
        bytes([255, 255, 255, 0]) +
        bytes([8, 8, 8, 8]) +
        bytes([8, 8, 4, 4]) +
        salt + b"ABC" +
        b"\x00"
    )
    ct1, tag1, iv1, crc1 = request_dhcp(dev_name=salt + b"ABC", debug=True)

    flush_dhcp(61)
    # ip = 192.168.1.3
    pt2 = bytearray(
        bytes([int(x) for x in "192.168.1.3".split(".")]) +
        bytes([int(x) for x in "192.168.1.1".split(".")]) +
        bytes([255, 255, 255, 0]) +
        bytes([8, 8, 8, 8]) +
        bytes([8, 8, 4, 4]) +
        salt + b"xyz" +
        b"\x00"
    )
    ct2, tag2, iv2, crc2 = request_dhcp(dev_name=salt + b"xyz", debug=True)

    assert iv1 == iv2
    assert xor(pt1, ct1) == xor(pt2, ct2)
    keystream = xor(pt1, ct1)

    f1 = create_poly(ct1)
    f2 = create_poly(ct2)
    t1 = int.from_bytes(tag1, byteorder='little')
    t2 = int.from_bytes(tag2, byteorder='little')

    keys = []
    for i in range(4):
        for j in range(4):
            fr = (t1 - t2 + 2**128*(i - j)) - (f1 - f2)
            for r, _ in fr.roots():


                if r < 0x0ffffffc0ffffffc0ffffffc0fffffff:
                    s = (t1  - int(f1.subs(x=r)))%2**128
                    print(f1(r)%P == f1(r))
                    ans = (int(r),int(s))
                    if ans not in keys:
                        print(ans)
                        keys.append(ans)

    flush_dhcp(61)
    # ip = 192.168.1.3
    pt3 = bytearray(
        bytes([int(x) for x in "192.168.1.3".split(".")]) +
        bytes([int(x) for x in "192.168.1.1".split(".")]) +
        bytes([255, 255, 255, 0]) +
        bytes([8, 8, 8, 8]) +
        bytes([8, 8, 4, 4]) +
        salt + b"vnc" +
        b"\x00"
    )
    ct3, tag3, iv3, crc3 = request_dhcp(dev_name=salt + b"vnc", debug=True)
    for r, s in keys:
        data  = b"" + pad16(b"")
        data += ct3 + pad16(ct3)
        data += struct.pack('<Q', 0)
        data += struct.pack('<Q', len(ct3))

        # print(Poly1305(r, s).create_tag(data).hex(), tag3.hex())

        if Poly1305(r, s).create_tag(data).hex() == tag3.hex():
            print(f"Found poly1305 key (r,s)=({r},{s})")

            flush_dhcp(60)
            # ip = 192.168.1.3
            msg = bytearray(
                bytes([int(x) for x in "192.168.1.3".split(".")]) +
                bytes([int(x) for x in "192.168.1.1".split(".")]) +
                bytes([255, 255, 255, 0]) +
                bytes([1,5,111,3]) +
                bytes([8,7,111,2]) +
                salt + b"vnc" +
                b"\x00"
            )
            ct = xor(msg, keystream)
            data  = b"" + pad16(b"")
            data += ct + pad16(ct)
            data += struct.pack('<Q', 0)
            data += struct.pack('<Q', len(ct))

            pkt = bytearray(
                bytes.fromhex("11 22 22 33 44 55") +    # src's mac
                bytes.fromhex("53 79 82 b5 97 eb") +    # dest's mac
                b"\x02"                            +    # seperator
                ct+Poly1305(r, s).create_tag(data)+iv1+calc_crc(msg)
            ).hex().encode()
            io.sendlineafter(b"> ", pkt)
            print(io.recvline())

            flush_dhcp(60)
            # ip = 192.168.1.3
            msg = bytearray(
                bytes([int(x) for x in "192.168.1.3".split(".")]) +
                bytes([int(x) for x in "192.168.1.1".split(".")]) +
                bytes([255, 255, 255, 0]) +
                bytes([194,233,68,172]) +
                bytes([194,233,68,172]) +
                salt + b"vnc" +
                b"\x00"
            )
            ct = xor(msg, keystream)
            data  = b"" + pad16(b"")
            data += ct + pad16(ct)
            data += struct.pack('<Q', 0)
            data += struct.pack('<Q', len(ct))

            pkt = bytearray(
                bytes.fromhex("11 22 22 33 44 55") +    # src's mac
                bytes.fromhex("53 79 82 b5 97 eb") +    # dest's mac
                b"\x03"                            +    # seperator
                ct+Poly1305(r, s).create_tag(data)+iv1+calc_crc(msg)
            ).hex().encode()
            io.sendlineafter(b"> ", pkt)

    io.interactive()
```
> **<gg>Flag: PCTF{d0nt_r3u5e_th3_n0nc3_d4839ed727736624}</gg>**