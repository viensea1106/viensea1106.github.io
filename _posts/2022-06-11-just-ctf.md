---
title:  "JustCTF 2022"
mathjax: true
layout: post
---

[JustCTF 2022](https://ctftime.org/event/1631/) writeup all Crypto challenges:
- Simply Powered
- Frosty
- fROSty's Second Signature Scheme

<img src="/images/2022-just-ctf/just-ctf-2022.png" width="100%">




# Simply Powered

> **Description**\
> *Just calculate root. :)*
>
> `# Use only one server:`\
> `nc simply-powered-ams3.nc.jctf.pro 4444 #  142.93.236.95`\
> `nc simply-powered-nyc3.nc.jctf.pro 4444 #  159.203.115.238`\
> `nc simply-powered-sgp1.nc.jctf.pro 4444 # 167.172.66.141`

Connect vÃ o server thÃ¬ ta tháº¥y server tráº£ vá» sá»‘ nguyÃªn tá»‘ $$p \in \mathbb{F_{p}}$$, sá»‘ nguyÃªn $$e \in \mathbb{Z}$$ vÃ  matrix $$A \in GL_{n}(\mathbb{F}_{p})$$ thá»a mÃ£n:

$$
A = M^{e} \pmod{p}
$$

Nhiá»‡m vá»¥ cá»§a ta lÃ  tÃ¬m ra matrix $$M$$ vÃ  gá»­i láº¡i server tá»•ng táº¥t cáº£ cÃ¡c entries cá»§a matrix $$M$$. HoÃ n thÃ nh $$100$$ rounds vá»›i Ä‘á»™ lá»›n $$n$$ tÄƒng dáº§n sáº½ cÃ³ `flag`.

NhÃ¬n cáº¥u trÃºc nÃ³ cÅ©ng giá»‘ng nhÆ° bÃ i toÃ¡n RSA Ä‘Ãºng khÃ´ngğŸ˜…Thay vÃ¬ giáº£i trÃªn $$\mathbb{Z_n}$$ vá»›i $$n = p \times q$$ thÃ¬ giá» lÃ   $$GL_{n}\left(\mathbb{F_{p}}\right)$$ - [General Linear Group](https://en.wikipedia.org/wiki/General_linear_group). Ã tÆ°á»Ÿng cÅ©ng tÆ°Æ¡ng tá»± tháº±ng $$\phi(n)$$ bÃªn RSA, bÃ¢y giá» chÃºng ta cÅ©ng quan tÃ¢m Ä‘áº¿n Ä‘áº¡i lÆ°á»£ng $$\lambda$$ thá»a mÃ£n:

$$
M^{\lambda} = \mathbb{I_n} \pmod{p} \quad \forall M \in GL_{n}\left(\mathbb{F_p}\right)
$$

vá»›i $$\mathbb{I_n}$$ lÃ  matrix Ä‘Æ¡n vá»‹. Sá»‘ $$\lambda$$ thá»a tÃ­nh cháº¥t trÃªn Ä‘Æ°á»£c gá»i lÃ  cáº¥p ($$ord$$) cá»§a $$GL_{n}\left(\mathbb{F_p}\right)$$, Ä‘Æ°á»£c tÃ­nh báº±ng cÃ´ng thá»©c (chá»©ng minh khÃ¡ dá»…, cÃ¡c báº¡n cÃ³ thá»ƒ Ä‘á»c link wiki mÃ¬nh Ä‘á»ƒ á»Ÿ trÃªn):

$$
\lambda = \prod_{k=0}^{n-1}\left(q^{n} - q^{k}\right) = (q^{n} - 1)(q^{n} - q)\cdots(q^{n} - q^{n-1}).
$$

Váº­y lÃºc nÃ y, $M$ Ä‘Æ°á»£c tÃ­nh báº±ng cÃ¡ch:

$$
M = A^{e^{-1} \pmod{\lambda}} \pmod{p}
$$

```python
#!/usr/bin/sage

from pwn import *

io = remote("simply-powered-ams3.nc.jctf.pro", 4444)

for _ in range(100):
  io.recvuntil(b'e = ')
  e = int(io.recvline())

  io.recvuntil(b'p = ')
  p = int(io.recvline())

  io.recvline()
  cmd = io.recvline()[:-1].decode()

  exec(f"MT = {cmd[:7]} GF({p}), {cmd[7:]}")  # not safe :(
  d = inverse_mod(e, MT.multiplicative_order())
  M = MT^d

  M = M.change_ring(ZZ)
  s = sum(sum(M))

  io.recvuntil(b'We expect you to provide sum(M % p) - sum of all elements in M % p.\n')
  io.sendline(str(s).encode())
  print(io.recvline())
```

> **<gg>Flag: justCTF{basic_math_just_fundamentals}</gg>**

# Frosty

> **Description**\
> *I just found this great new multisignature scheme, we can collaborate to sign messages together!* `nc frosty.nc.jctf.pro 4444`\
> PS: The connections are dropped automatically after 4 minutes.
>
> **Attachments**\
> **[source](https://github.com/sajjadium/ctf-archives/tree/main/ctfs/justCTF/2022/crypto/Frosty)**

```python
import json
import hashlib
from fastecdsa.curve import P192 as Curve
from fastecdsa.point import Point

from secrets import randbits

from server_config import flag

N = Curve.q.bit_length()

registered_keys = {}

def read() -> dict:
    return json.loads(input())

def write(m : dict):
    print(json.dumps(m))

def parse_ec(p):
    return Point(int(p[0], 16), int(p[1], 16), Curve)

def generate_nonce():
    sk = randbits(N)
    return sk, sk*Curve.G

def mod_hash(msg : bytes, R : Point) -> int:
    h = hashlib.sha256()
    h.update(len(msg).to_bytes(64, 'big'))
    h.update(msg)
    h.update(R.x.to_bytes(N//8, 'big'))
    h.update(R.y.to_bytes(N//8, 'big'))
    return int(h.hexdigest(), 16) % Curve.q

def verify(pubkey : Point, m : bytes, z : int, c : int) -> bool:
    R = z*Curve.G - c * pubkey
    return c == mod_hash(m, R)

def coords(p : Point) -> (str, str):
    return (hex(p.x)[2:], hex(p.y)[2:])

def genkey():
    sk, server_share = generate_nonce()
    write({"pubkey_share": coords(server_share)})
    pk = read()["pubkey_share"]
    client_share = parse_ec(pk)
    public_key = server_share + client_share
    registered_keys[public_key] = sk
    write({"registered":coords(public_key)})


def sign(pubkey : Point):
    if pubkey not in registered_keys:
        write({"error": "Unknown pubkey"})
        return
    secret_key = registered_keys[pubkey]
    secret_nonce, public_nonce = generate_nonce()
    write({"D": coords(public_nonce)})
    response = read()
    client_nonce = parse_ec(response["D"])
    msg = bytes.fromhex(response["msg"])
    R = public_nonce + client_nonce
    if (msg == b"Gimme!"):
        write({"error":"No way Jose!"})
        return
    c = mod_hash(msg, R)
    z = secret_nonce + secret_key * c
    write({"z":hex(z)[2:]})

def serve():
    try:
        write({"banner": "Welcome to Frosty's Snowman Signing Server. Choose an option: genkey, sign or verify"})
        msg = read()
        if msg["op"] == "genkey":
            genkey()
        elif msg["op"] == "sign":
            sign(parse_ec(msg["pubkey"]))
        elif msg["op"] == "verify":
            m = bytes.fromhex(msg["m"])
            z = int(msg["z"], 16)
            c = int(msg["c"], 16)
            pubkey = parse_ec(msg["pubkey"])
            verified = verify(pubkey, m, z, c)
            write({"verified": verified})
            if verified and m == b'Gimme!':
                write({"flag": flag})
    except (ValueError, KeyError, TypeError, json.decoder.JSONDecodeError):
        write({"error": "Invalid input"})

if __name__ == "__main__":
    while True:
        serve()
```

Äá»c sÆ¡ qua thÃ¬ bÃ i nÃ y Ä‘ang xÃ¢y dá»±ng `multisignature scheme` dá»±a trÃªn [Curve P-192](https://neuromancer.sk/std/nist/P-192). TÃ¡c giáº£ release 2 version cho bÃ i nÃ y, Ä‘Ã¢y lÃ  version Ä‘áº§u tiÃªn, do sai sÃ³t nÃªn dÃ­nh bug unintended á»Ÿ hÃ m <b>`verify`</b>

```python
def verify(pubkey : Point, m : bytes, z : int, c : int) -> bool:
    R = z*Curve.G - c * pubkey
    return c == mod_hash(m, R)
```

Má»¥c tiÃªn cá»§a ta lÃ  chá»n $$\text{pubkey}, z, c$$ sao cho hÃ m `verify` thá»a mÃ£n vá»›i $$m = \text{"Gimme!"}$$. Ta tháº¥y náº¿u chá»n $$\text{pubkey} = G, z = c$$ thÃ¬ $$R = 0$$. Váº­y chá»‰ viá»‡c chá»n:

- $$m = \text{"Gimme!"}$$.
- $$\text{pubkey} = G$$.
- z = c = mod_hash(m, 0).

thÃ¬ hÃ m `verify` sáº½ thá»a mÃ£n!

```python
from pwn import *
import json
import hashlib
from fastecdsa.curve import P192 as Curve
from fastecdsa.point import Point

G = Curve.G
N = Curve.q.bit_length()

def coords(p : Point):
  return (hex(p.x)[2:], hex(p.y)[2:])

def mod_hash(msg : bytes, R : Point) -> int:
  h = hashlib.sha256()
  h.update(len(msg).to_bytes(64, 'big'))
  h.update(msg)
  h.update(R.x.to_bytes(N//8, 'big'))
  h.update(R.y.to_bytes(N//8, 'big'))
  return int(h.hexdigest(), 16) % Curve.q

def send(io, data):
  io.sendline(json.dumps(data).encode())

if __name__ == "__main__":
  io = process(["python3", "frosty.py"])
  io.recvline()

  h = mod_hash(b"Gimme!", G - G)
  send(io, {
    "op": "verify",
    "m": b"Gimme!".hex(),
    "z": hex(h),
    "c": hex(h),
    "pubkey": coords(G),
  })

  io.interactive()
```

> **<gg>Flag: justCTF{this_was_not_so_smart}</gg>**

# fROSty's Second Signature Scheme

> **Description**\
> *Distributed key generation is hard, so just use the keys below. No more funny stuff, OK?*\
> Your private key share: `0xee669fa9dc3e12154d13ac6bc17d6c3b2291832dadd76746`\
> My public key share: `(0x9532cae35947c6211c2f808145aa193f9773e591b03f3e1b, 0x3df6739646175efd21fe509d8b1f436fa4f6663b4eec9641)`
>
> **Attachments**\
> **[source](https://github.com/sajjadium/ctf-archives/tree/main/ctfs/justCTF/2022/crypto/fROStysSecondSignatureScheme)**

```python
import json
import hashlib
from fastecdsa.curve import P192 as Curve
from fastecdsa.point import Point

from secrets import randbits

from server_config import flag, server_privkey_share, client_pubkey_share

N = Curve.q.bit_length()
server_pubkey_share = server_privkey_share * Curve.G
pubkey = client_pubkey_share + server_pubkey_share

def read() -> dict:
    return json.loads(input())

def write(m : dict):
    print(json.dumps(m))

def generate_nonce():
    sk = randbits(N)
    return sk, sk*Curve.G

def mod_hash(msg : bytes, R : Point) -> int:
    h = hashlib.sha256()
    h.update(len(msg).to_bytes(64, 'big'))
    h.update(msg)
    h.update(R.x.to_bytes(N//8, 'big'))
    h.update(R.y.to_bytes(N//8, 'big'))
    return int(h.hexdigest(), 16) % Curve.q

def verify(pubkey : Point, m : bytes, z : int, c : int) -> bool:
    R = z*Curve.G - c * pubkey
    return c == mod_hash(m, R)

def coords(p : Point) -> (str, str):
    return (hex(p.x)[2:], hex(p.y)[2:])


def sign():
    secret_nonce, public_nonce = generate_nonce()
    write({"D": coords(public_nonce)})
    response = read()
    (dx, dy) = response["D"]
    msg = bytes.fromhex(response["msg"])
    client_nonce = Point(int(dx, 16), int(dy, 16), Curve)
    R = public_nonce + client_nonce
    if (msg == b"Gimme!"):
        write({"error":"No way Jose!"})
        return
    c = mod_hash(msg, R)
    z = secret_nonce + server_privkey_share * c
    write({"z":hex(z)[2:]})

def serve():
    try:
        write({"banner": "Welcome to Very Frosty's Snowman Signing Server. Choose an option: sign or verify"})
        msg = read()
        if msg["op"] == "sign":
            sign()
        elif msg["op"] == "verify":
            m = bytes.fromhex(msg["m"])
            z = int(msg["z"], 16)
            c = int(msg["c"], 16)
            verified = verify(pubkey, m, z, c)
            write({"verified": verified})
            if verified and m == b'Gimme!':
                write({"flag": flag})
    except (ValueError, KeyError, TypeError, json.decoder.JSONDecodeError):
        write({"error": "Invalid input"})

if __name__ == "__main__":
    serve()
```

Láº§n nÃ y thÃ¬ hÃ m `verify` Ä‘Æ°á»£c patched láº¡i vÃ  bá» Ä‘i bÆ°á»›c `genkey`. Äáº§u tiÃªn ta phÃ¢n tÃ­ch sÆ¡ qua cÃ¡c hÃ m chÃ­nh cÃ³ trong source code.

<b>constants:</b> Äáº§u tiÃªn lÃ  cÃ¡c háº±ng Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a trÆ°á»›c:
- $$N, G$$ láº§n lÆ°á»£t lÃ  `order` vÃ  `generator` cá»§a Curve P-192.
- $$G_{s} = s_{s} \times G$$ lÃ  `server` public key, tham sá»‘ nÃ y cho trÆ°á»›c vÃ  luÃ´n cá»‘ Ä‘á»‹nh.
- $$G_{c} = s_{c} \times G$$ lÃ  `client` public key, tham sá»‘ nÃ y cho trÆ°á»›c vÃ  luÃ´n cá»‘ Ä‘á»‹nh.
- $$G_{share} = G_{s} + G_{c}$$ lÃ  `shared` public key, hai bÃªn `client` vÃ  `server` Ä‘á»u tá»± tÃ­nh Ä‘Æ°á»£c vÃ  tham sá»‘ nÃ y cÅ©ng luÃ´n cá»‘ Ä‘á»‹nh.

<b>generate_nonce:</b> DÃ¹ng Ä‘á»ƒ táº¡o cáº·p `nonce` á»Ÿ hai phÃ­a `client` vÃ  `server`
- Private: $$n \in [0, N)$$
- Public: $$n \times G$$

<b>mod_hash:</b> HÃ m nÃ y dÃ¹ng Ä‘á»ƒ hash má»™t chuá»—i message `msg` vá»›i má»™t Ä‘iá»ƒm $$R$$ trÃªn Curve.

<p align="center">
  <img src="/images/2022-just-ctf/mod_hash.png">
</p>

<b>sign:</b> HÃ m nÃ y dÃ¹ng Ä‘á»ƒ kÃ½ $$G_{share}$$ vá»›i `msg` do `client` gá»­i lÃªn, cÃ¡c bÆ°á»›c thá»±c hiá»‡n nhÆ° sau:
- Äáº§u tiÃªn `server` sinh ra cáº·p `nonce` $$\left(n_{s}, n_{s} \times G\right)$$ vÃ  gá»­i $$n_{s} \times G$$ cho `client`.
- PhÃ­a `client` tÆ°á»Ÿng tá»± cÅ©ng sinh cáº·p `nonce` $$\left(n_{c}, n_{c} \times G\right)$$ vÃ  gá»­i $$n_{c} \times G$$ cho `server`, Ä‘á»“ng thá»i cÅ©ng gá»­i lÃªn `msg` cho `server` kÃ½.
- Sau Ä‘Ã³ phÃ­a `server` láº§n lÆ°á»£t tÃ­nh cÃ¡c giÃ¡ trá»‹ $$R = (n_{s} + n_{c})\times G$$, $$c =$$ mod_hash(msg, R), $$z = n_{s} + s_{s}\times c$$, vá»›i $$s_{s}$$ lÃ  `server` private key.
- Cuá»‘i cÃ¹ng `server` tráº£ vá» giÃ¡ trá»‹ `signature` $$z$$ cho `client`.

<b>verify:</b> HÃ m nÃ y Ä‘á»ƒ xÃ¡c nháº­n `signature` theo cÃ¡c bÆ°á»›c sau
- Äáº§u tiÃªn `client` gá»­i lÃªn `server` cÃ¡c giÃ¡ trá»‹ `signature` $$z$$, `message` $$m$$ vÃ  `mod_hash` $$c$$.
- `server` tiáº¿n hÃ nh verify báº±ng cÃ¡ch tÃ­nh giÃ¡ trá»‹ $$R = z \times G - c \times G_{share}$$ vÃ  kiá»ƒm tra xem:

$$
c \overset{?}{=} mod\_hash(m, R).
$$

<b>Flow Challenge:`</b>
- Má»—i láº§n connect tá»›i `server`, phÃ­a `client` chá»‰ Ä‘Æ°á»£c phÃ©p thá»±c hiá»‡n má»™t trong hai chá»©c nÄƒng `sign` vÃ  `verify`.
- Äá»ƒ láº¥y Ä‘Æ°á»£c `flag` cáº§n verify thÃ nh cÃ´ng vá»›i `msg` lÃ  `"Gimme!"`.

Ã tÆ°á»Ÿng giáº£i quyáº¿t cÅ©ng tÆ°Æ¡ng tá»± láº§n trÆ°á»›c, náº¿u ta khá»•i phá»¥c Ä‘Æ°á»£c `secret share` $$s_{s}$$ cá»§a `server` thÃ¬ khi Ä‘Ã³ gá»i hÃ m `verify` vá»›i cÃ¡c tham sá»‘:

- $$m = \text{"Gimme!"}$$.
- c = mod_hash(m, 0).
- $$z = c \times (s_{s} + s_{c})$$. Vá»›i $$s_{c}$$ lÃ  `secret share` cá»§a `client`, giÃ¡ trá»‹ nÃ y cá»‘ Ä‘á»‹nh vÃ  Ä‘Ã£ Ä‘Æ°á»£c cho trÆ°á»›c.

sáº½ thÃ nh cÃ´ng! VÃ¬ cÃ¡c giÃ¡ trá»‹ secret Ä‘Æ°á»£c cá»‘ Ä‘á»‹nh nÃªn ta sáº½ nghÄ© cÃ¡ch connect vÃ  gá»i hÃ m `sign` nhiá»u láº§n sao cho leak Ä‘Æ°á»£c $$s_{s}$$ lÃ  xong. Nháº­n tháº¥y má»—i láº§n `sign` má»™t `msg` báº¥t kÃ¬ ta cÃ³

$$
z = \mathbb{n_{s}} + \mathbb{s_{s}} \times c
$$

vá»›i $$(z, c)$$ Ä‘Ã£ biáº¿t cÃ²n $$\left(\mathbb{n_{s}}, \mathbb{s_{s}}\right)$$ lÃ  áº©n, hÆ¡n ná»¯a: $$n_{s}, c \sim 2^{192}$$. LÆ°u Ã½ $$n_{s}$$ lÃ  giÃ¡ trá»‹ `nonce` vÃ  thay Ä‘á»•i liÃªn tá»¥c, nÃªn náº¿u cÃ³ trÆ°á»ng há»£p $$n_{s} < c$$ thÃ¬ ngay láº­p tá»©c ta tÃ­nh Ä‘Æ°á»£c $$s_{s}$$ báº±ng cÃ¡ch

$$
s_{s} = \Bigg\lfloor \dfrac{z}{c} \Bigg\rfloor
$$

```python
from pwn import *
import json
import hashlib
from fastecdsa.curve import P192 as Curve
from fastecdsa.point import Point

G = Curve.G
N = Curve.q.bit_length()
client_prikey = 0xee669fa9dc3e12154d13ac6bc17d6c3b2291832dadd76746
client_pubkey = client_prikey * G
server_pubkey = Point(0x9532cae35947c6211c2f808145aa193f9773e591b03f3e1b, 0x3df6739646175efd21fe509d8b1f436fa4f6663b4eec9641, Curve)
pubkey = client_pubkey + server_pubkey

def parse_ec(p):
  return Point(int(p[0], 16), int(p[1], 16), Curve)

def coords(p : Point):
  return (hex(p.x)[2:], hex(p.y)[2:])

def mod_hash(msg : bytes, R : Point) -> int:
  h = hashlib.sha256()
  h.update(len(msg).to_bytes(64, 'big'))
  h.update(msg)
  h.update(R.x.to_bytes(N//8, 'big'))
  h.update(R.y.to_bytes(N//8, 'big'))
  return int(h.hexdigest(), 16) % Curve.q

def send_json(io, data):
  io.sendline(json.dumps(data).encode())

def load_json(io):
  return json.loads(io.recvline().strip().decode())

def sign(io, msg=b"vnc"):
  send_json(io, {"op": "sign"})
  public_nonce = load_json(io)["D"]
  send_json(io, {"D": public_nonce, "msg": msg.hex()})
  z = int(load_json(io)["z"], 16)
  c = mod_hash(b"vnc", 2*parse_ec(public_nonce))
  return z//c

def connect():
  return process(["python3", "frosty.py"])

if __name__ == "__main__":
  brute = []

  for _ in range(10):
    io = connect()
    io.recvline()
    brute.append(sign(io))
    io.close()
  
  server_prikey = min(brute)
  
  io = connect()
  c = mod_hash(b"Gimme!", G-G)
  send_json(io, {
    "op": "verify",
    "m": b"Gimme!".hex(),
    "c": hex(c)[2:],
    "z": hex(c * (client_prikey + server_prikey))[2:], 
  })

  io.interactive()
```

> **<gg>Flag: justCTF{Elsa_was_here!}</gg>**