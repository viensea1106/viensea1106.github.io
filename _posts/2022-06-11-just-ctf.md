---
title:  "JustCTF 2022"
mathjax: true
layout: post
---

[JustCTF 2022](https://ctftime.org/event/1631/) writeup all Crypto challenges:
- Simply Powered
- Frosty
- fROSty's Second Signature Scheme

<img src="/images/2022-just-ctf/just-ctf-2022.png" width="100%">




# Simply Powered

> **Description**\
> *Just calculate root. :)*
>
> `# Use only one server:`\
> `nc simply-powered-ams3.nc.jctf.pro 4444 #  142.93.236.95`\
> `nc simply-powered-nyc3.nc.jctf.pro 4444 #  159.203.115.238`\
> `nc simply-powered-sgp1.nc.jctf.pro 4444 # 167.172.66.141`

Connect v√†o server th√¨ ta th·∫•y server tr·∫£ v·ªÅ s·ªë nguy√™n t·ªë $$p \in \mathbb{F_{p}}$$, s·ªë nguy√™n $$e \in \mathbb{Z}$$ v√† matrix $$A \in GL_{n}(\mathbb{F}_{p})$$ th·ªèa m√£n:

$$
A = M^{e} \pmod{p}
$$

Nhi·ªám v·ª• c·ªßa ta l√† t√¨m ra matrix $$M$$ v√† g·ª≠i l·∫°i server t·ªïng t·∫•t c·∫£ c√°c entries c·ªßa matrix $$M$$. Ho√†n th√†nh $$100$$ rounds v·ªõi ƒë·ªô l·ªõn $$n$$ tƒÉng d·∫ßn s·∫Ω c√≥ `flag`.

Nh√¨n c·∫•u tr√∫c n√≥ c≈©ng gi·ªëng nh∆∞ b√†i to√°n RSA ƒë√∫ng kh√¥ngüòÖThay v√¨ gi·∫£i tr√™n $$\mathbb{Z_n}$$ v·ªõi $$n = p \times q$$ th√¨ gi·ªù l√†  $$GL_{n}\left(\mathbb{F_{p}}\right)$$ - [General Linear Group](https://en.wikipedia.org/wiki/General_linear_group). √ù t∆∞·ªüng c≈©ng t∆∞∆°ng t·ª± th·∫±ng $$\phi(n)$$ b√™n RSA, b√¢y gi·ªù ch√∫ng ta c≈©ng quan t√¢m ƒë·∫øn ƒë·∫°i l∆∞·ª£ng $$\lambda$$ th·ªèa m√£n:

$$
M^{\lambda} = \mathbb{I_n} \pmod{p} \quad \forall M \in GL_{n}\left(\mathbb{F_p}\right)
$$

v·ªõi $$\mathbb{I_n}$$ l√† matrix ƒë∆°n v·ªã. S·ªë $$\lambda$$ th·ªèa t√≠nh ch·∫•t tr√™n ƒë∆∞·ª£c g·ªçi l√† c·∫•p ($$ord$$) c·ªßa $$GL_{n}\left(\mathbb{F_p}\right)$$, ƒë∆∞·ª£c t√≠nh b·∫±ng c√¥ng th·ª©c (ch·ª©ng minh kh√° d·ªÖ, c√°c b·∫°n c√≥ th·ªÉ ƒë·ªçc link wiki m√¨nh ƒë·ªÉ ·ªü tr√™n):

$$
\lambda = \prod_{k=0}^{n-1}\left(q^{n} - q^{k}\right) = (q^{n} - 1)(q^{n} - q)\cdots(q^{n} - q^{n-1}).
$$

V·∫≠y l√∫c n√†y, $M$ ƒë∆∞·ª£c t√≠nh b·∫±ng c√°ch:

$$
M = A^{e^{-1} \pmod{\lambda}} \pmod{p}
$$

```python
#!/usr/bin/sage

from pwn import *

io = remote("simply-powered-ams3.nc.jctf.pro", 4444)

for _ in range(100):
  io.recvuntil(b'e = ')
  e = int(io.recvline())

  io.recvuntil(b'p = ')
  p = int(io.recvline())

  io.recvline()
  cmd = io.recvline()[:-1].decode()

  exec(f"MT = {cmd[:7]} GF({p}), {cmd[7:]}")  # not safe :(
  d = inverse_mod(e, MT.multiplicative_order())
  M = MT^d

  M = M.change_ring(ZZ)
  s = sum(sum(M))

  io.recvuntil(b'We expect you to provide sum(M % p) - sum of all elements in M % p.\n')
  io.sendline(str(s).encode())
  print(io.recvline())
```

> **<gg>Flag: justCTF{basic_math_just_fundamentals}</gg>**

# Frosty

> **Description**\
> *I just found this great new multisignature scheme, we can collaborate to sign messages together!* `nc frosty.nc.jctf.pro 4444`\
> PS: The connections are dropped automatically after 4 minutes.
>
> **Attachments**\
> **[source](https://github.com/sajjadium/ctf-archives/tree/main/ctfs/justCTF/2022/crypto/Frosty)**

```python
import json
import hashlib
from fastecdsa.curve import P192 as Curve
from fastecdsa.point import Point

from secrets import randbits

from server_config import flag

N = Curve.q.bit_length()

registered_keys = {}

def read() -> dict:
    return json.loads(input())

def write(m : dict):
    print(json.dumps(m))

def parse_ec(p):
    return Point(int(p[0], 16), int(p[1], 16), Curve)

def generate_nonce():
    sk = randbits(N)
    return sk, sk*Curve.G

def mod_hash(msg : bytes, R : Point) -> int:
    h = hashlib.sha256()
    h.update(len(msg).to_bytes(64, 'big'))
    h.update(msg)
    h.update(R.x.to_bytes(N//8, 'big'))
    h.update(R.y.to_bytes(N//8, 'big'))
    return int(h.hexdigest(), 16) % Curve.q

def verify(pubkey : Point, m : bytes, z : int, c : int) -> bool:
    R = z*Curve.G - c * pubkey
    return c == mod_hash(m, R)

def coords(p : Point) -> (str, str):
    return (hex(p.x)[2:], hex(p.y)[2:])

def genkey():
    sk, server_share = generate_nonce()
    write({"pubkey_share": coords(server_share)})
    pk = read()["pubkey_share"]
    client_share = parse_ec(pk)
    public_key = server_share + client_share
    registered_keys[public_key] = sk
    write({"registered":coords(public_key)})


def sign(pubkey : Point):
    if pubkey not in registered_keys:
        write({"error": "Unknown pubkey"})
        return
    secret_key = registered_keys[pubkey]
    secret_nonce, public_nonce = generate_nonce()
    write({"D": coords(public_nonce)})
    response = read()
    client_nonce = parse_ec(response["D"])
    msg = bytes.fromhex(response["msg"])
    R = public_nonce + client_nonce
    if (msg == b"Gimme!"):
        write({"error":"No way Jose!"})
        return
    c = mod_hash(msg, R)
    z = secret_nonce + secret_key * c
    write({"z":hex(z)[2:]})

def serve():
    try:
        write({"banner": "Welcome to Frosty's Snowman Signing Server. Choose an option: genkey, sign or verify"})
        msg = read()
        if msg["op"] == "genkey":
            genkey()
        elif msg["op"] == "sign":
            sign(parse_ec(msg["pubkey"]))
        elif msg["op"] == "verify":
            m = bytes.fromhex(msg["m"])
            z = int(msg["z"], 16)
            c = int(msg["c"], 16)
            pubkey = parse_ec(msg["pubkey"])
            verified = verify(pubkey, m, z, c)
            write({"verified": verified})
            if verified and m == b'Gimme!':
                write({"flag": flag})
    except (ValueError, KeyError, TypeError, json.decoder.JSONDecodeError):
        write({"error": "Invalid input"})

if __name__ == "__main__":
    while True:
        serve()
```

ƒê·ªçc s∆° qua th√¨ b√†i n√†y ƒëang x√¢y d·ª±ng `multisignature scheme` d·ª±a tr√™n [Curve P-192](https://neuromancer.sk/std/nist/P-192). T√°c gi·∫£ release 2 version cho b√†i n√†y, ƒë√¢y l√† version ƒë·∫ßu ti√™n, do sai s√≥t n√™n d√≠nh bug unintended ·ªü h√†m <b>`verify`</b>

```python
def verify(pubkey : Point, m : bytes, z : int, c : int) -> bool:
    R = z*Curve.G - c * pubkey
    return c == mod_hash(m, R)
```

M·ª•c ti√™n c·ªßa ta l√† ch·ªçn $$\text{pubkey}, z, c$$ sao cho h√†m `verify` th·ªèa m√£n v·ªõi $$m = \text{"Gimme!"}$$. Ta th·∫•y n·∫øu ch·ªçn $$\text{pubkey} = G, z = c$$ th√¨ $$R = 0$$. V·∫≠y ch·ªâ vi·ªác ch·ªçn:

- $$m = \text{"Gimme!"}$$.
- $$\text{pubkey} = G$$.
- z = c = mod_hash(m, 0).

th√¨ h√†m `verify` s·∫Ω th·ªèa m√£n!

```python
from pwn import *
import json
import hashlib
from fastecdsa.curve import P192 as Curve
from fastecdsa.point import Point

G = Curve.G
N = Curve.q.bit_length()

def coords(p : Point):
  return (hex(p.x)[2:], hex(p.y)[2:])

def mod_hash(msg : bytes, R : Point) -> int:
  h = hashlib.sha256()
  h.update(len(msg).to_bytes(64, 'big'))
  h.update(msg)
  h.update(R.x.to_bytes(N//8, 'big'))
  h.update(R.y.to_bytes(N//8, 'big'))
  return int(h.hexdigest(), 16) % Curve.q

def send(io, data):
  io.sendline(json.dumps(data).encode())

if __name__ == "__main__":
  io = process(["python3", "frosty.py"])
  io.recvline()

  h = mod_hash(b"Gimme!", G - G)
  send(io, {
    "op": "verify",
    "m": b"Gimme!".hex(),
    "z": hex(h),
    "c": hex(h),
    "pubkey": coords(G),
  })

  io.interactive()
```

> **<gg>Flag: justCTF{this_was_not_so_smart}</gg>**

# fROSty's Second Signature Scheme

> **Description**\
> *Distributed key generation is hard, so just use the keys below. No more funny stuff, OK?*\
> Your private key share: `0xee669fa9dc3e12154d13ac6bc17d6c3b2291832dadd76746`\
> My public key share: `(0x9532cae35947c6211c2f808145aa193f9773e591b03f3e1b, 0x3df6739646175efd21fe509d8b1f436fa4f6663b4eec9641)`
>
> **Attachments**\
> **[source](https://github.com/sajjadium/ctf-archives/tree/main/ctfs/justCTF/2022/crypto/fROStysSecondSignatureScheme)**

```python
import json
import hashlib
from fastecdsa.curve import P192 as Curve
from fastecdsa.point import Point

from secrets import randbits

from server_config import flag, server_privkey_share, client_pubkey_share

N = Curve.q.bit_length()
server_pubkey_share = server_privkey_share * Curve.G
pubkey = client_pubkey_share + server_pubkey_share

def read() -> dict:
    return json.loads(input())

def write(m : dict):
    print(json.dumps(m))

def generate_nonce():
    sk = randbits(N)
    return sk, sk*Curve.G

def mod_hash(msg : bytes, R : Point) -> int:
    h = hashlib.sha256()
    h.update(len(msg).to_bytes(64, 'big'))
    h.update(msg)
    h.update(R.x.to_bytes(N//8, 'big'))
    h.update(R.y.to_bytes(N//8, 'big'))
    return int(h.hexdigest(), 16) % Curve.q

def verify(pubkey : Point, m : bytes, z : int, c : int) -> bool:
    R = z*Curve.G - c * pubkey
    return c == mod_hash(m, R)

def coords(p : Point) -> (str, str):
    return (hex(p.x)[2:], hex(p.y)[2:])


def sign():
    secret_nonce, public_nonce = generate_nonce()
    write({"D": coords(public_nonce)})
    response = read()
    (dx, dy) = response["D"]
    msg = bytes.fromhex(response["msg"])
    client_nonce = Point(int(dx, 16), int(dy, 16), Curve)
    R = public_nonce + client_nonce
    if (msg == b"Gimme!"):
        write({"error":"No way Jose!"})
        return
    c = mod_hash(msg, R)
    z = secret_nonce + server_privkey_share * c
    write({"z":hex(z)[2:]})

def serve():
    try:
        write({"banner": "Welcome to Very Frosty's Snowman Signing Server. Choose an option: sign or verify"})
        msg = read()
        if msg["op"] == "sign":
            sign()
        elif msg["op"] == "verify":
            m = bytes.fromhex(msg["m"])
            z = int(msg["z"], 16)
            c = int(msg["c"], 16)
            verified = verify(pubkey, m, z, c)
            write({"verified": verified})
            if verified and m == b'Gimme!':
                write({"flag": flag})
    except (ValueError, KeyError, TypeError, json.decoder.JSONDecodeError):
        write({"error": "Invalid input"})

if __name__ == "__main__":
    serve()
```

L·∫ßn n√†y th√¨ h√†m `verify` ƒë∆∞·ª£c patched l·∫°i v√† b·ªè ƒëi b∆∞·ªõc `genkey`. ƒê·∫ßu ti√™n ta ph√¢n t√≠ch s∆° qua c√°c h√†m ch√≠nh c√≥ trong source code.

<b>constants:</b> ƒê·∫ßu ti√™n l√† c√°c h·∫±ng ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a tr∆∞·ªõc:
- $$N, G$$ l·∫ßn l∆∞·ª£t l√† `order` v√† `generator` c·ªßa Curve P-192.
- $$G_{s} = s_{s} \times G$$ l√† `server` public key, tham s·ªë n√†y cho tr∆∞·ªõc v√† lu√¥n c·ªë ƒë·ªãnh.
- $$G_{c} = s_{c} \times G$$ l√† `client` public key, tham s·ªë n√†y cho tr∆∞·ªõc v√† lu√¥n c·ªë ƒë·ªãnh.
- $$G_{share} = G_{s} + G_{c}$$ l√† `shared` public key, hai b√™n `client` v√† `server` ƒë·ªÅu t·ª± t√≠nh ƒë∆∞·ª£c v√† tham s·ªë n√†y c≈©ng lu√¥n c·ªë ƒë·ªãnh.

<b>generate_nonce:</b> D√πng ƒë·ªÉ t·∫°o c·∫∑p `nonce` ·ªü hai ph√≠a `client` v√† `server`
- Private: $$n \in [0, N)$$
- Public: $$n \times G$$

<b>mod_hash:</b> H√†m n√†y d√πng ƒë·ªÉ hash m·ªôt chu·ªói message `msg` v·ªõi m·ªôt ƒëi·ªÉm $$R$$ tr√™n Curve.

<p align="center">
  <img src="/images/2022-just-ctf/mod_hash.png">
</p>

<b>sign:</b> H√†m n√†y d√πng ƒë·ªÉ k√Ω $$G_{share}$$ v·ªõi `msg` do `client` g·ª≠i l√™n, c√°c b∆∞·ªõc th·ª±c hi·ªán nh∆∞ sau:
- ƒê·∫ßu ti√™n `server` sinh ra c·∫∑p `nonce` $$\left(n_{s}, n_{s} \times G\right)$$ v√† g·ª≠i $$n_{s} \times G$$ cho `client`.
- Ph√≠a `client` t∆∞·ªüng t·ª± c≈©ng sinh c·∫∑p `nonce` $$\left(n_{c}, n_{c} \times G\right)$$ v√† g·ª≠i $$n_{c} \times G$$ cho `server`, ƒë·ªìng th·ªùi c≈©ng g·ª≠i l√™n `msg` cho `server` k√Ω.
- Sau ƒë√≥ ph√≠a `server` l·∫ßn l∆∞·ª£t t√≠nh c√°c gi√° tr·ªã $$R = (n_{s} + n_{c})\times G$$, $$c =$$ mod_hash(msg, R), $$z = n_{s} + s_{s}\times c$$, v·ªõi $$s_{s}$$ l√† `server` private key.
- Cu·ªëi c√πng `server` tr·∫£ v·ªÅ gi√° tr·ªã `signature` $$z$$ cho `client`.

<b>verify:</b> H√†m n√†y ƒë·ªÉ x√°c nh·∫≠n `signature` theo c√°c b∆∞·ªõc sau
- ƒê·∫ßu ti√™n `client` g·ª≠i l√™n `server` c√°c gi√° tr·ªã `signature` $$z$$, `message` $$m$$ v√† `mod_hash` $$c$$.
- `server` ti·∫øn h√†nh verify b·∫±ng c√°ch t√≠nh gi√° tr·ªã $$R = z \times G - c \times G_{share}$$ v√† ki·ªÉm tra xem:

$$
c \overset{?}{=} mod\_hash(m, R).
$$

<b>Flow Challenge:`</b>
- M·ªói l·∫ßn connect t·ªõi `server`, ph√≠a `client` ch·ªâ ƒë∆∞·ª£c ph√©p th·ª±c hi·ªán m·ªôt trong hai ch·ª©c nƒÉng `sign` v√† `verify`.
- ƒê·ªÉ l·∫•y ƒë∆∞·ª£c `flag` c·∫ßn verify th√†nh c√¥ng v·ªõi `msg` l√† `"Gimme!"`.

√ù t∆∞·ªüng gi·∫£i quy·∫øt c≈©ng t∆∞∆°ng t·ª± l·∫ßn tr∆∞·ªõc, n·∫øu ta kh·ªïi ph·ª•c ƒë∆∞·ª£c `secret share` $$s_{s}$$ c·ªßa `server` th√¨ khi ƒë√≥ g·ªçi h√†m `verify` v·ªõi c√°c tham s·ªë:

- $$m = \text{"Gimme!"}$$.
- c = mod_hash(m, 0).
- $$z = c \times (s_{s} + s_{c})$$. V·ªõi $$s_{c}$$ l√† `secret share` c·ªßa `client`, gi√° tr·ªã n√†y c·ªë ƒë·ªãnh v√† ƒë√£ ƒë∆∞·ª£c cho tr∆∞·ªõc.

s·∫Ω th√†nh c√¥ng! V√¨ c√°c gi√° tr·ªã secret ƒë∆∞·ª£c c·ªë ƒë·ªãnh n√™n ta s·∫Ω nghƒ© c√°ch connect v√† g·ªçi h√†m `sign` nhi·ªÅu l·∫ßn sao cho leak ƒë∆∞·ª£c $$s_{s}$$ l√† xong. Nh·∫≠n th·∫•y m·ªói l·∫ßn `sign` m·ªôt `msg` b·∫•t k√¨ ta c√≥

$$
z = \mathbb{n_{s}} + \mathbb{s_{s}} \times c
$$

v·ªõi $$(z, c)$$ ƒë√£ bi·∫øt c√≤n $$\left(\mathbb{n_{s}}, \mathbb{s_{s}}\right)$$ l√† ·∫©n, h∆°n n·ªØa: $$n_{s}, c \sim 2^{192}$$. L∆∞u √Ω $$n_{s}$$ l√† gi√° tr·ªã `nonce` v√† thay ƒë·ªïi li√™n t·ª•c, n√™n n·∫øu c√≥ tr∆∞·ªùng h·ª£p $$n_{s} < c$$ th√¨ ngay l·∫≠p t·ª©c ta t√≠nh ƒë∆∞·ª£c $$s_{s}$$ b·∫±ng c√°ch

$$
s_{s} = \Bigg\lfloor \dfrac{z}{c} \Bigg\rfloor
$$

```python
from pwn import *
import json
import hashlib
from fastecdsa.curve import P192 as Curve
from fastecdsa.point import Point

G = Curve.G
N = Curve.q.bit_length()
client_prikey = 0xee669fa9dc3e12154d13ac6bc17d6c3b2291832dadd76746
client_pubkey = client_prikey * G
server_pubkey = Point(0x9532cae35947c6211c2f808145aa193f9773e591b03f3e1b, 0x3df6739646175efd21fe509d8b1f436fa4f6663b4eec9641, Curve)
pubkey = client_pubkey + server_pubkey

def parse_ec(p):
  return Point(int(p[0], 16), int(p[1], 16), Curve)

def coords(p : Point):
  return (hex(p.x)[2:], hex(p.y)[2:])

def mod_hash(msg : bytes, R : Point) -> int:
  h = hashlib.sha256()
  h.update(len(msg).to_bytes(64, 'big'))
  h.update(msg)
  h.update(R.x.to_bytes(N//8, 'big'))
  h.update(R.y.to_bytes(N//8, 'big'))
  return int(h.hexdigest(), 16) % Curve.q

def send_json(io, data):
  io.sendline(json.dumps(data).encode())

def load_json(io):
  return json.loads(io.recvline().strip().decode())

def sign(io, msg=b"vnc"):
  send_json(io, {"op": "sign"})
  public_nonce = load_json(io)["D"]
  send_json(io, {"D": public_nonce, "msg": msg.hex()})
  z = int(load_json(io)["z"], 16)
  c = mod_hash(b"vnc", 2*parse_ec(public_nonce))
  return z//c

def connect():
  return process(["python3", "frosty.py"])

if __name__ == "__main__":
  brute = []

  for _ in range(10):
    io = connect()
    io.recvline()
    brute.append(sign(io))
    io.close()
  
  server_prikey = min(brute)
  
  io = connect()
  c = mod_hash(b"Gimme!", G-G)
  send_json(io, {
    "op": "verify",
    "m": b"Gimme!".hex(),
    "c": hex(c)[2:],
    "z": hex(c * (client_prikey + server_prikey))[2:], 
  })

  io.interactive()
```

> **<gg>Flag: justCTF{Elsa_was_here!}</gg>**